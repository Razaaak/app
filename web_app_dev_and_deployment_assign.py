# -*- coding: utf-8 -*-
"""Web App Dev and Deployment Assign.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16mZCi0w51qJcavyHCAQFIdk2H6IO-dS0
"""

!pip install pandas scikit-learn joblib matplotlib seaborn streamlit
!wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
!chmod +x cloudflared-linux-amd64
!mv cloudflared-linux-amd64 /usr/local/bin/cloudflared

print("Libraries and Cloudflare Tunnel installed!")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile model_training.py
# import pandas as pd
# from sklearn.model_selection import train_test_split, GridSearchCV
# from sklearn.linear_model import LinearRegression
# from sklearn.ensemble import RandomForestRegressor
# from sklearn.metrics import r2_score
# import joblib
# import numpy as np
# 
# print("Starting model training script...")
# 
# try:
#     df = pd.read_csv('beer-servings.csv')
#     print("Dataset loaded successfully.")
# except FileNotFoundError:
#     print("Error: 'beer-servings.csv' not found. Please ensure it's in the same directory.")
#     exit()
# 
# print("Starting data preprocessing...")
# 
# if df.columns[0] == 'Unnamed: 0':
#     df = df.drop(columns=[df.columns[0]])
# 
# numerical_cols = ['beer_servings', 'spirit_servings', 'wine_servings', 'total_litres_of_pure_alcohol']
# for col in numerical_cols:
#     if df[col].isnull().any():
#         median_val = df[col].median()
#         df[col] = df[col].fillna(median_val)
#         print(f"Filled missing values in '{col}' with median: {median_val}")
# 
# categorical_cols = ['country', 'continent']
# for col in categorical_cols:
#     if df[col].isnull().any():
#         df[col] = df[col].fillna('Unknown')
#         print(f"Filled missing values in '{col}' with 'Unknown'.")
# 
# df_encoded = pd.get_dummies(df, columns=['country', 'continent'], drop_first=True)
# print("Categorical features one-hot encoded.")
# 
# X = df_encoded.drop('total_litres_of_pure_alcohol', axis=1)
# y = df_encoded['total_litres_of_pure_alcohol']
# 
# feature_columns = X.columns.tolist()
# print(f"Features for training: {feature_columns}")
# 
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# print(f"Data split into training ({len(X_train)} samples) and testing ({len(X_test)} samples).")
# 
# models = {
#     'Linear Regression': LinearRegression(),
#     'Random Forest Regressor': RandomForestRegressor(random_state=42)
# }
# 
# best_model = None
# best_r2_score = -np.inf
# best_model_name = ""
# 
# for name, model in models.items():
#     print(f"\n--- Training {name} ---")
#     if name == 'Random Forest Regressor':
#         param_grid = {
#             'n_estimators': [50, 100, 200],
#             'max_features': ['sqrt', 'log2'],
#             'max_depth': [5, 10, None]
#         }
#         grid_search = GridSearchCV(model, param_grid, cv=3, scoring='r2', n_jobs=-1, verbose=1)
#         grid_search.fit(X_train, y_train)
#         model = grid_search.best_estimator_
#         print(f"Best parameters for {name}: {grid_search.best_params_}")
#     else:
#         model.fit(X_train, y_train)
# 
#     y_pred = model.predict(X_test)
#     r2 = r2_score(y_test, y_pred)
#     print(f"R2-score for {name} on evaluation data: {r2:.4f}")
# 
#     if r2 > best_r2_score:
#         best_r2_score = r2
#         best_model = model
#         best_model_name = name
# 
# print(f"\nBest model selected for deployment: {best_model_name} with R2-score: {best_r2_score:.4f}")
# 
# model_filename = 'best_beer_predictor_model.joblib'
# joblib.dump(best_model, model_filename)
# print(f"Best model saved as '{model_filename}'")
# 
# feature_columns_filename = 'feature_columns.joblib'
# joblib.dump(feature_columns, feature_columns_filename)
# print(f"Feature columns saved as '{feature_columns_filename}'")
# 
# print("Model training script finished successfully.")

!python model_training.py

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import joblib
# import matplotlib.pyplot as plt
# import seaborn as sns
# import io
# import os # Import os module to check for file existence
# 
# st.set_page_config(
#     page_title="Beer Servings Predictor",
#     layout="centered",
#     initial_sidebar_state="auto"
# )
# 
# st.title("ðŸº Beer Servings Alcohol Predictor")
# st.markdown("A web application to predict the total litres of pure alcohol based on serving data and geographical information.")
# 
# # Add a simple message to confirm the app itself is loading
# st.write("App initialized. Attempting to load data and model...")
# 
# 
# # --- Load the trained model and feature columns ---
# try:
#     if os.path.exists('best_beer_predictor_model.joblib'):
#         model = joblib.load('best_beer_predictor_model.joblib')
#         st.sidebar.success("Model loaded successfully!")
#     else:
#         st.sidebar.error("Error: 'best_beer_predictor_model.joblib' not found!")
#         st.stop() # Stop the app if model is missing
# 
#     if os.path.exists('feature_columns.joblib'):
#         feature_columns = joblib.load('feature_columns.joblib')
#         st.sidebar.success("Feature columns loaded successfully!")
#     else:
#         st.sidebar.error("Error: 'feature_columns.joblib' not found!")
#         st.stop() # Stop the app if feature columns are missing
# 
# except Exception as e:
#     st.error(f"Error loading model or feature columns: {e}. Please ensure 'model_training.py' was run successfully and files are in the repository root.")
#     st.exception(e) # Display full exception for debugging
#     st.stop()
# 
# 
# # --- Load the original dataset for infographics and dropdown options ---
# @st.cache_data
# def load_data():
#     file_path = 'beer-servings.csv'
#     if not os.path.exists(file_path):
#         st.error(f"Error: Dataset '{file_path}' not found in the repository root!")
#         return pd.DataFrame() # Return empty DataFrame if file not found
# 
#     try:
#         df = pd.read_csv(file_path)
#         st.sidebar.success(f"Dataset '{file_path}' loaded successfully.")
# 
#         if df.columns[0] == 'Unnamed: 0':
#             df = df.drop(columns=[df.columns[0]])
# 
#         # Preprocess data consistent with model training script (impute NaNs)
#         numerical_cols = ['beer_servings', 'spirit_servings', 'wine_servings', 'total_litres_of_pure_alcohol']
#         for col in numerical_cols:
#             if df[col].isnull().any():
#                 median_val = df[col].median()
#                 df[col] = df[col].fillna(median_val)
# 
#         categorical_cols = ['country', 'continent']
#         for col in categorical_cols:
#             if df[col].isnull().any():
#                 df[col] = df[col].fillna('Unknown')
#         return df
#     except Exception as e:
#         st.error(f"Error loading or preprocessing dataset: {e}")
#         st.exception(e)
#         return pd.DataFrame()
# 
# df = load_data()
# 
# # Check if data loaded successfully before proceeding with UI elements
# if df.empty:
#     st.warning("Cannot proceed: Data for infographics and prediction inputs is not available.")
#     st.stop() # Stop further execution if data is missing
# 
# unique_countries = sorted([c for c in df['country'].unique().tolist() if c != 'Unknown'])
# unique_continents = sorted([c for c in df['continent'].unique().tolist() if c != 'Unknown'])
# 
# 
# # --- Infographics Section ---
# st.header("ðŸ“Š Data Infographics")
# 
# # Only display charts if data is loaded
# if not df.empty:
#     st.subheader("Total Litres of Pure Alcohol by Continent")
#     continent_alcohol = df.groupby('continent')['total_litres_of_pure_alcohol'].sum().reset_index()
#     fig, ax = plt.subplots(figsize=(10, 6))
#     sns.barplot(x='continent', y='total_litres_of_pure_alcohol', data=continent_alcohol, ax=ax, palette='viridis')
#     ax.set_title('Total Litres of Pure Alcohol by Continent', fontsize=16)
#     ax.set_xlabel('Continent', fontsize=12)
#     ax.set_ylabel('Total Litres of Pure Alcohol (L)', fontsize=12)
#     plt.xticks(rotation=45, ha='right')
#     plt.tight_layout()
#     st.pyplot(fig)
#     st.markdown("This bar chart displays the aggregated total litres of pure alcohol consumed across different continents. It highlights regions with higher overall consumption.")
# 
#     st.subheader("Beer Servings vs. Total Litres of Pure Alcohol (by Country)")
#     fig2, ax2 = plt.subplots(figsize=(10, 6))
#     sns.scatterplot(x='beer_servings', y='total_litres_of_pure_alcohol', data=df, ax=ax2, hue='continent', palette='deep', s=100, alpha=0.7)
#     ax2.set_title('Beer Servings vs. Total Litres of Pure Alcohol', fontsize=16)
#     ax2.set_xlabel('Beer Servings (ml)', fontsize=12)
#     ax2.set_ylabel('Total Litres of Pure Alcohol (L)', fontsize=12)
#     plt.tight_layout()
#     st.pyplot(fig2)
#     st.markdown("This scatter plot illustrates the relationship between beer servings and total pure alcohol consumption per country, with points colored by continent. It helps visualize potential correlations and clusters.")
# else:
#     st.warning("Data not available to display infographics.")
# 
# 
# # --- Prediction Section ---
# st.header("ðŸ”® Make a Prediction")
# st.markdown("Enter the serving details and select the country/continent to get a prediction for the total litres of pure alcohol.")
# 
# col1, col2, col3 = st.columns(3)
# with col1:
#     beer_servings = st.number_input("Beer Servings (ml)", min_value=0, value=100, step=10, help="Enter the amount of beer servings in milliliters.")
# with col2:
#     spirit_servings = st.number_input("Spirit Servings (ml)", min_value=0, value=50, step=5, help="Enter the amount of spirit servings in milliliters.")
# with col3:
#     wine_servings = st.number_input("Wine Servings (ml)", min_value=0, value=20, step=5, help="Enter the amount of wine servings in milliliters.")
# 
# selected_country = st.selectbox("Country", options=unique_countries, help="Select the country for which to make a prediction.")
# selected_continent = st.selectbox("Continent", options=unique_continents, help="Select the continent for which to make a prediction.")
# 
# if st.button("Predict Total Litres of Pure Alcohol"):
#     try:
#         input_data = {
#             'beer_servings': beer_servings,
#             'spirit_servings': spirit_servings,
#             'wine_servings': wine_servings
#         }
# 
#         for col in feature_columns:
#             if col.startswith('country_') or col.startswith('continent_'):
#                 input_data[col] = 0
# 
#         country_col_name = f'country_{selected_country}'
#         if country_col_name in feature_columns:
#             input_data[country_col_name] = 1
#         else:
#             st.warning(f"Warning: Country '{selected_country}' was not a distinct category in the training data. Its specific effect might not be captured.")
# 
#         continent_col_name = f'continent_{selected_continent}'
#         if continent_col_name in feature_columns:
#             input_data[continent_col_name] = 1
#         else:
#             st.warning(f"Warning: Continent '{selected_continent}' was not a distinct category in the training data. Its specific effect might not be captured.")
# 
#         input_df = pd.DataFrame([input_data])
#         input_df = input_df.reindex(columns=feature_columns, fill_value=0)
# 
#         prediction = model.predict(input_df)[0]
#         st.success(f"**Predicted Total Litres of Pure Alcohol:** {prediction:.2f} L")
# 
#     except Exception as e:
#         st.error(f"An error occurred during prediction: {e}")
#         st.exception(e)
# 
# st.markdown("---")
# st.markdown("Developed as a Web App Development and Deployment Case Study.")
# st.markdown("Powered by Streamlit, Scikit-learn, Matplotlib, and Seaborn.")

import subprocess
import threading
import time
import requests

streamlit_port = 8501

def run_streamlit_process():
    cmd = f"nohup streamlit run app.py --server.port {streamlit_port} --server.enableCORS false --server.enableXsrfProtection false > streamlit_app.log 2>&1 &"
    subprocess.run(cmd, shell=True)

def wait_for_streamlit_ready(port, timeout=60):
    start_time = time.time()
    print(f"Waiting for Streamlit server to become ready on port {port}...")
    while True:
        try:
            response = requests.get(f"http://localhost:{port}/_stcore/health")
            if response.status_code == 200:
                print(f"Streamlit server is ready on port {port}.")
                return True
        except requests.exceptions.ConnectionError:
            pass
        if time.time() - start_time > timeout:
            print(f"Streamlit server did not become ready within {timeout} seconds.")
            return False
        time.sleep(1)
print("Starting Streamlit app in background...")
thread = threading.Thread(target=run_streamlit_process)
thread.daemon = True
thread.start()
print(f"Streamlit app process initiated on port {streamlit_port}")

if not wait_for_streamlit_ready(streamlit_port):
    print("Streamlit app did not start. Aborting Cloudflare Tunnel setup.")
else:

    time.sleep(5)
    print("Opening Cloudflare Tunnel...")
    try:
        cf_process = subprocess.Popen(
            f"/usr/local/bin/cloudflared tunnel --url http://localhost:{streamlit_port}",
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        public_url = None
        start_tunnel_wait_time = time.time()

        print("\n--- Cloudflare Tunnel Output (Live) ---")
        while True:

            stderr_line = cf_process.stderr.readline()
            if stderr_line:
                print(f"[Cloudflared STDERR]: {stderr_line.strip()}")
                if "https://" in stderr_line and ("your random tunnel" in stderr_line or "tunnel ID" in stderr_line):

                    try:
                        url_match = stderr_line.split("https://")[1]
                        public_url = "https://" + url_match.split(" ")[0].strip()
                        if not public_url.endswith("/"):
                            public_url += "/"
                        print(f"\n--- Found Public URL: {public_url} ---")
                        break
                    except IndexError:
                        pass


            stdout_line = cf_process.stdout.readline()
            if stdout_line:
                print(f"[Cloudflared STDOUT]: {stdout_line.strip()}")

            if cf_process.poll() is not None:
                if public_url:
                    break
                else:
                    print("Cloudflare Tunnel process terminated without providing a URL.")
                    break
            if time.time() - start_tunnel_wait_time > 120:
                print("Cloudflare Tunnel timed out while waiting for URL. It might still be running or failed silently.")
                break

            time.sleep(0.5)
        if cf_process.poll() is None:
            print("Terminating Cloudflare Tunnel process...")
            cf_process.terminate()
            time.sleep(1)
            if cf_process.poll() is None:
                cf_process.kill()
            print("Cloudflare Tunnel process terminated.")


        if public_url:
            print(f"\nYour Streamlit app is publicly accessible at: {public_url}")
            print("\nClick the link above to open your app!")
            print("This URL should NOT require a password and can be shared.")
            print("If the app doesn't load immediately, please wait a few seconds and refresh the page.")
        else:
            print("\nFailed to get Cloudflare Tunnel URL after extensive monitoring.")
            print("This usually means cloudflared encountered an issue or its output format changed significantly.")
            print("Check the full [Cloudflared STDERR] and [Cloudflared STDOUT] above for clues.")

    except Exception as e:
        print(f"\nAn unexpected Python error occurred while setting up Cloudflare Tunnel: {e}")
        import traceback
        traceback.print_exc()
        print("Please ensure `cloudflared` executable is in /usr/local/bin/ and has execute permissions.")
        print("You can try reinstalling: `!wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64` and `!chmod +x cloudflared-linux-amd64` and `!mv cloudflared-linux-amd64 /usr/local/bin/cloudflared`")